원시타입과 객체타입의 차이

원시타입의 값은 변경불가능한값 vs 객체타입은 변경가능한 값

값에 의한 전달(Pass by value)이란?

변수에 변수를 할당하는 경우, 할당되는 변수가 원시값을 갖는 변수라면 할당받는 변수에는 할당되는 변수의 원시값이 복사되어 전달된다.

얕은 복사(shallow copy)와 깊은 복사(deep copy)이란?

참조 값을 복사하는 것을 얕은 복사(shallow copy), 원시 값처럼 객체 자체를 복사하여 다시 생성하는 것을 깊은 복사(deep copy)라 한다.

참조에 의한 전달(Pass by reference)이란?

객체를 가리키는 변수 원본을 다른 변수사본에 할당하면 원본의 참조 값이 복사되어 전달된다

함수 사용이유

코드의 재사용, 유지보수 편리성, 신뢰성 높임,가독성 향상

함수정의의 4가지

함수선언문, 함수 표현식 , Function 생성자함수, 화살표 함수





var score=80;
score=90;
의 값의 할당 과정에 대해서 설명하세요. (원시값이 변경 불가능한 값일때와 변경 가능한 값인 경우로 나누어서 설명)

원시값이 변경불가능하기 때문에 최초에 score에 undefined가 할당된후 80으로 재할당,

다시 90으로 재할당된다.

변경 가능한 값일 경우 : 메모리에 같은 주소에 score라는 이름을 붙이고, 최초 undefined라는 값이 할당되고, 그 자리에 80이 할당되고, 다시 그자리에 90 이 할당된다.
불가능한 값일 경우 : 메모리에 undefined를 가르키는 주소에 score라는 이름을 붙이고, 80을 가지고 있는 메모리 다른 주소에 있는 값을 가르키게 바꾸고, 90을 만나면 90을 가지고 있는 메모리 다른 주소에 있는 값을 가르키게 바꾼다.



```
var foo = 10; 
var bar = foo;

foo = 100;

console.log(foo, bar);   
```

- 위 코드의 결과를 말하고, pass by value에 대해 설명해주세요.(그림그려서)

foo는 100, bar는 10이 나온다. foo는 10을 값으로 가지는 메모리 공간을 가르키고 있다. bar는 그 foo가 가지고 있던 값인 10을 복사해서 다른 메모리주소 셀에 집어 넣고 거기에 bar라는 이름을 붙인다. 3번째 줄을 만나면 foo가 10을 가르키고 있던것이 또 다른 주소인 100을 값으로 가지는 곳으로 변경되어 출력



console.dir(add); console.dir(sub);

```
console.log(add(2, 5)); 
console.log(sub(2, 5)); 

function add(x, y) {
  return x + y;
}

var sub = function (x, y) {
  return x - y;
};
```

- 위 코드의 결과는?

f add(x,y) / undefined / 7 / TypeError: sub is not a function



```
let c = { greeting: 'Hey!' };
let d;

d = c;
c.greeting = 'Hello';
console.log(d.greeting);
```

위 코드의 결과는? 

hello





```
for ( var i = 0; i < 3; i++ ) {
	setTimeout(() => console.log(i), 1);
}

for (let i = 0; i < 3; i++) {
	setTimeOut(() => console.log(i), 1);
}
```

1ms 이후 333 012 가 출력,

var는 블록레벨 스코프를 지원하지 않는다. let은 블록레벨 스코프를 지원한다.

setTimeout함수는 비동기 함수로 콜스택이 비어져있을때 호출된다.

위 2가지 이유로 인하여, 1ms 이후에 var의 i는 이미 for문에서 빠져나올때 3이 되어서 빠져나오고 3을 3번 찍는다.

아래의 let으로 선언된 i는 0,1,2가 차례대로 찍힌다.



원시 값이 변경 불가능하다는 것은 변수에 한 번 할당한 값을 다시 할당할 수 없다는 뜻이다. (O / X)

답 x

함수를 사용하는 이유를 2개 이상 말하시오.

답 유지보수의 편의성을 높이기 위해, 코드의 재사용성, 가독성을 향상시키므로 등등

자바스크립트에서 함수를 정의하는 방법을 모두 말하시오.

답 함수 선언문, 함수 표현식, Function 생성자 함수, 화살표 함수

함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수가 호이스팅 부분에서 어떻게 다르게 동작하는지 말하시오.

함수 선언문은 선언문이므로 호이스팅이 되어 선언문 이전에도 참조하고 호출할 수 있지만,

함수 표현식은 함수명으로 사용할 변수에 함수 표현식으로 만든 함수 객체를 **할당하는 것**이기 때문에 할당문 이전에 호출하면 Type Error가 발생한다. undefined를 호출하는 것이기 때문이다.

다음 중 오류를 발생시키는 코드는? (에러의 이유와 같이 설명)

```
// 1. 
(function () {
	// ... 
}());

// 2.
function () { 
  // ...
}();

// 3.
(function () {
  // ...
})();

// 4.
(function foo() {
 // ...
}());

// 5.
!function () {
  // ...
}();

// 6.
+function () {
  // ...
}();

// 7.
function foo() {
  // ...
}();
```

1. SyntaxError: Unexpected token ( 함수 선언문의 형식에 맞지 않아서 (함수명없음)
2. SyntaxError: Unexpected token ) 자바스크립트 엔진은 함수 선언문이 끝나는 부분에 암묵적으로 ;를 붙이므로 (); 에서 에러남

Q. deep copy와 pass by value의 연관성

원시 값은 신뢰성을 보장하기 위해 값을 복사해서 전달한다. 이러한 과정을 pass by value라 하는데 이때 값을 복사하는 것을 deep copy라고 한다.

Q. 자바스크립트는 클래스 없이 객체를 생성할 수 없다. ( O / X )

X, 자바스크립트는 클래스 없이 객체 생성이 가능하다.

Q. 함수 선언문은 식별자를 생략해 즉시실행 함수로 만들수 있다. ( O / X )

X, 함수 선언문은 식별자를 생략 할수 없다. 즉시실행 함수를 만들때 `()`로 감싸는 경우에는 식별자를 생략 할수 있다.

Q. 함수의 parameter보다 argument가 많을 경우, 초과되는 argument는 무시되고 가비지 컬렉터에 의해 메모리가 해제 된다. ( O / X )

X, 무시 되지만 사라지지 않고 argument의 요소가 된다.

Q. 자바스크립트에서 함수는 함수의 parameter로 전달되어 argument가 될수 있다. 이것이 가능한 이유와 이러한 함수를 무엇이라 부르는가

자바스크립트의 함수는 first-class object이기 때문이다. (first-class object는 값처럼 변수에 할당 될수 있고 프로퍼티의 값이 될수도 있으며 배열요소가 될수 있다.) 이처럼 함수에 전달되는 함수를 콜백 함수라고 부른다.





```
var person = { name: 'Lee' };

var copy = person;

console.log(person === copy); // ?
```

true



```
var str = 'alphabet';
console.log(str[0]); // a

str[0] = 'A';

console.log(str); // ?
```

- alphabet



```
const str = 'string';

str.forEach((s)=> {
	s = 'S';
    console.log(s);
}) // ??
```

TypeError: str.forEach is not a function

순수함수란?

어떤 외부 상태도 변경시키지 않는, 즉 부수 효과가 없는 함수

함수형 프로그래밍이란?

변수의 사용을 억제하여 상태 변경을 피하고 순수 함수와 보조 함수의 조합을 통해 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하려는 프로그래밍 패러다임





```
//기명 즉시 실행 함수
(function foo() {
  var a = 3;
  var b = 5;
  return a * b;
}());

foo();
```

ReferenceError: foo is not defined



Q1. 자바스크립트의 문자열은 (     ) 타입이며 변경 (     ) 하다.

원시, 불가능

Q2. 유사 배열 객체에 대한 특징을 3가지 설명하시오.

1. 배열처럼 인덱스 프로퍼티 값에 접근할 수 있다.
2. length 프로퍼티를 갖는다.
3. For문으로 순회 할 수도 있다.

Q3. 자바스크립트에서의 객체 관리 방식에서 객체가 생성된 이후에도 프로퍼티를 추가 할 수 있다.

X 객체가 생성된 이후에는 프로퍼티를 추가 할 수 없다.

Q4. 함수는 (     ) 면에서 매우 유용하다.

코드의 재사용

Q5. 함수의 이름을 생략하는 것을 무엇이라고 칭하는가?

익명 함수(anonymous function)

Q6. 매개 변수의 이상적인 갯수는 몇 개인가?

0개

함수란?

일련의 과정을 문(statement)들로 구현하고 코드 블록으로 감싸서 하나의 실행 단위로 정의한 것

함수 선언문과 함수 표현식에 차이를 인터프리터 관점에서 설명해보시오.

함수 선언문으로 함수를 정의하면 자바스크립트 엔진에 의해 다른 코드가 실행되기 이전에 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 함수 객체를 생성하여 할당한다. 즉, 다른 코드가 실행되기 이전에 이미 함수 객체가 생성되고 함수 이름과 동일한 변수에 할당까지 완료된 상태다. 따라서 함수 선언문 이전에 함수를 참조할 수 있으며 호출할 수도 있다.(함수 호이스팅-선언, 초기화, 할당 동시진행)

함수 표현식은 변수 할당문의 값이 함수 리터럴인 문이다. 따라서 함수 표현식은 변수 선언문과 변수 할당문을 한번에 기술한 축약 표현과 동일하게 동작한다. 변수 선언은 런타임 이전에 실행되어 undefined로 초기화되지만, 변수 할당문의 값은 할당문이 실행되는 시점, 즉 런타임에 평가되므로 함수 표현식의 함수 리터럴도 할당문이 실행되는 시점에 평가되어 함수 객체가 된다.